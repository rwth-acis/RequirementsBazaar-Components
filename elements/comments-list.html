<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../paper-toast/paper-toast.html">
<link rel="import" href="../../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../iron-meta/iron-meta.html">
<link rel="import" href="../shared-styles.html">
<link rel="import" href="req-user.html">

<dom-module id="comments-list">
  <template>
    <style include="shared-styles iron-flex iron-flex-alignment">
      :host {
        display: block;
        font-size: 90%;
      }

      /**
       * Inspired by http://stackoverflow.com/questions/25685227/how-to-display-user-profile-image-in-circle
       */
      .profileImage {
        width: 40px;
        height: 40px;
        border-radius: 50%; /*don't forget prefixes*/
        background-position: center center;
        /* as mentioned by Vad: */
        background-size: cover;
        margin-right: 10px;
      }

      .noComments {
        font-style: italic;
      }

      .info {
        margin: 5px 0 10px 0;
        font-size: small;
      }

      .comment {
        margin-top: 5px;
      }

      .reply {
        margin-left: 40px;
      }

      .flexchild {
        @apply(--layout-flex);
      }

      .flex-end-align {
        margin-top: auto;
        margin-bottom: auto;
      }

      .actions {
        font-size: 12px;
        color: #90949c;
      }

      paper-toast {
        z-index: 105;
      }

      a {
        text-decoration: underline;
        cursor: pointer;
      }

      .content-wrapper {
        overflow-y: auto;
      }

      .content {
        word-break: break-word;
        word-wrap: break-word;
      }
    </style>

    <!-- XHR for loading comments: -->

    <iron-ajax id="commentsRequest"
               loading="{{loading}}"
               url="{{resourceURL}}"
               headers="[[authHeader]]"
               last-response="{{comments}}"
               params='{"page":"0", "per_page":"150"}'></iron-ajax>

    <!-- XHR for posting comments: -->

    <iron-ajax id="postCommentRequest"
               loading="{{loading}}"
               handle-as="json"
               content-type="application/json"
               method="POST"
               url="{{_apiBaseUrl}}comments"
               headers="[[authHeader]]"
               on-response="handlePostResponseComment"
               last-response="{{postResponse}}"
               on-error="errorHandler"></iron-ajax>

    <!-- Show this when no comments are there after loading -->
    <div class="noComments" hidden$="[[_computeNoCommentsHidden(comments)]]">No comments yet...</div>

    <!-- Comments -->

    <template is="dom-repeat" items="{{comments}}" on-dom-change="_handleCommentsDomChange">

      <!-- Compute the styling classes, add attribute "reply" when it is a reply. -->
      <div class$="[[_computeCommentClasses(item)]]" attr="{{item.id}}">
        <div class="profileImage" style$="[[getProfileStyle(item.creator.profileImage)]]"></div>
        <div class="layout vertical flex content-wrapper">
          <div inner-h-t-m-l="{{_validateUrlAndReplaceNewLines(item.message)}}" class="content"></div>
          <div class="actions">
            <a on-click="_handleReplyTap" hidden="[[!authorized]]">Reply</a>
            <span hidden="[[!isCreator(item.creator.id)]]"> · <a on-click="_handleDeleteTap">Delete</a> · </span>
            <relative-time time="[[item.creationDate]]"></relative-time>by<req-user user="[[item.creator]]" normal-view></req-user>
          </div>
          <div class="layout horizontal end">
            <!--<paper-input class$="replyInput[[item.id]] flexchild" attr="{{item.id}}" label="Reply to comment..." on-keydown="_checkForEnter" hidden></paper-input>-->
            <paper-textarea label="Reply to comment..." class$="replyInput[[item.id]] flexchild"
                            attr="{{item.id}}"
                            on-keydown="_checkForEnter" hidden></paper-textarea>
            <paper-icon-button mini icon="send" class$="commentSendButton[[item.id]]" on-click="_handleAddCommentTap" hidden></paper-icon-button>
          </div>
        </div>
      </div>

    </template>

    <!-- Toast for app notifications: -->

    <paper-toast id="toast"></paper-toast>

  </template>

  <script>
      class commentsList extends Polymer.Element{
          static get is() { return 'comments-list'; }

          static get properties() {
              return {
                  _apiBaseUrl: {
                      type: String,
                      value: 'https://requirements-bazaar.org/bazaar/'
                  },
                  _fileApiBaseUrl: {
                      type: String,
                      value: 'https://requirements-bazaar.org/fileservice/files/'
                  },
                  currentUser: {
                      type: String
                  },
                  /**
                   * Defines whether the user is logged in or not.
                   */
                  authorized: {
                      type: Boolean,
                      value: false
                  },
                  authHeader: {
                      type: Array
                  },
                  authToken: {
                      type: String,
                      observer: '_authTokenChanged'
                  },
                  /** Input from the requirement-list */
                  requirementId: {
                      type: Number
                  },
                  /** iron-ajax url for loading the requirement */
                  resourceURL: {
                      type: String,
                      computed: '_computeResourceURL(requirementId)'
                  },
                  /** contains all comment objects */
                  comments: {
                      type: Array,
                      notify: true
                  },
                  /**
                   * The ID of the comment to be deleted.
                   */
                  _currentDeleteId: {
                      type: Number
                  },
                  authorized: {
                      type: Boolean
                  },
                  /**
                   * Whether any loading operation is currently active.
                   */
                  loading: {
                      type: Boolean,
                      notify: true
                  }
              };
          }

          _authTokenChanged(token) {
              this.authorized = true;
              this.authHeader = {authorization: "Bearer " + token};
          }

          /**
           * Computes the classes for styling of a comment div tag. If comment is a reply then the reply class is added
           * @param comment
           * @returns {string}
           */
          _computeCommentClasses(comment) {
              var commentClasses = "comment layout horizontal";
              if (this.isReply(comment)) {
                  commentClasses += " reply";
              }
              return commentClasses;
          }

          /**
           * Computes the URL for sending a GET request to the comments for the specific requirement
           * @param requirementId
           * @returns {string}
           */
          _computeResourceURL(requirementId) {
              return this._apiBaseUrl + 'requirements/' + requirementId + '/comments/';
          }

          /**
           * Calculates whether the "no comments" div is shown or not.
           */
          _computeNoCommentsHidden(comments) {
              if (this.comments !== undefined) {
                  if (this.comments.length === 0) {
                      return false;
                  }
              }

              return true;
          }

          /**
           * Checks if at the end of typing in a reply paper-input the key Enter is Pressed.
           * If that's the case a request is create with non-empty text of the paper-input and the attr that corresponds
           * to comment that is being replied to.
           * @param e
           */
          _checkForEnter(e) {
              if (e.keyCode === 13) {
                  // check if the Enter key was pressed...
                  if (e.ctrlKey) {
                      this._handleAddCommentTap(e);
                      e.preventDefault();
                  }
              }
          }

          /**
           * Handles tapping the add reply button.
           */
          _handleAddCommentTap(e) {
              var text = this.shadowRoot.querySelector('.replyInput' + e.model.item.id).value;
              var replyTo;
              if (e.model.item.replyToComment) {
                  replyTo = e.model.item.replyToComment;
              } else {
                  replyTo = e.model.item.id;
              }
              var request = this.shadowRoot.querySelector('#postCommentRequest');
              if (text != null && text != '') {
                  request.body = JSON.stringify({
                      "requirementId": this.requirementId,
                      "message": text,
                      "replyToComment": parseInt(replyTo)
                  });
                  request.generateRequest();
              } else {
                  //show message for empty comment
                  this.shadowRoot.querySelector('#toast').text = 'Comment can\'t be empty!';
                  this.shadowRoot.querySelector('#toast').open();
              }
              //clear the paper-input and hide it
              this.shadowRoot.querySelector('.replyInput' + e.model.item.id).value = '';
              this.shadowRoot.querySelector('.replyInput' + e.model.item.id).hidden = true;
              this.shadowRoot.querySelector('.commentSendButton' + e.model.item.id).hidden = true;

              // notify container to resize
              let event = new CustomEvent('resize', {bubbles: true, composed: true});
              this.dispatchEvent(event);
          }

          /**
           * Handles the response after a reply comment is posted.
           * It loads the list of comments after the post is made.
           */
          handlePostResponseComment() {
              if (this.postResponse) {
                  this.refresh();
              }
          }

          /**
           * In case of any error display the toast with the corresponding error message
           *
           * @param e - event
           * @param detail - details of the event object
           */
          errorHandler(e, detail) {
              this.shadowRoot.querySelector('#toast').text = detail.error.message;
              this.shadowRoot.querySelector('#toast').open();
          }

          /**
           * Computes the style of the profile picture returning the css for div class= profilePicture
           *
           * @param profileImage
           * @returns {string}
           */
          getProfileStyle(profileImage) {
              return 'background-image: url("' + profileImage + '");';
          }

          /**
           * Generates request for loading comments.
           */
          refresh() {
              this.shadowRoot.querySelector('#commentsRequest').generateRequest();
          }

          /**
           * Deletes the comment if the dialog modal is confirmed, sends a DELETE request and refreshes the comments.
           *
           * @param e
           */
          _handleDeleteDialogClosed(e) {
              if (e.detail.confirmed) {
                  var request = this.shadowRoot.querySelector('#deleteCommentRequest');
                  request.url = this._apiBaseUrl + "comments/" + this._currentDeleteId;
                  request.generateRequest();
              }
          }

          _handleDeleteCommentResponse(e) {
              if (e.target.method === 'DELETE') {
                  this.shadowRoot.querySelector('#toast').text = 'he comment was successfully deleted.';
                  this.shadowRoot.querySelector('#toast').open();

                  this.refresh();
              }
          }

          /**
           * Checks if the usrId passed matches the logged-in user.
           *
           * @param usrId {Number}
           * @returns {boolean}
           */
          isCreator(usrId) {
              if (this.authorized && this.currentUser) {
                  if (usrId === this.currentUser.id) {
                      return true;
                  }
              }
              return false;
          }

          /**
           * Checks if a comment is a reply
           *
           * @param item - the comment item passed from the comments list
           * @returns {boolean}
           */
          isReply(item) {
              if (item.replyToComment) {
                  return true;
              }
              return false;
          }

          /**
           * Shows an input field for replying to a comment
           *
           * @param e
           */
          _handleReplyTap(e) {
              var replyInput = this.shadowRoot.querySelector('.replyInput' + e.model.item.id);
              var commentSendButton = this.shadowRoot.querySelector('.commentSendButton' + e.model.item.id);

              replyInput.hidden = false;
              commentSendButton.hidden = false;
              replyInput.focus();

              // notify container to resize
              let event = new CustomEvent('resize', {bubbles: true, composed: true});
              this.dispatchEvent(event);

              e.preventDefault();
          }

          /**
           * Event handler for tapping the delete comment link.
           *
           * @property e
           */
          _handleDeleteTap(e) {
              var data = {};
              data.comment = e.model.item;
              data.onDelete = function() {
                  // delete the comment from the model
                  for (var i = 0; i<this.comments.length; i++) {
                      if (this.comments[i].id === data.comment.id) {
                          this.splice('comments', i, 1);
                      }
                  }
              }.bind(this);
              let event = new CustomEvent('delete-comment', {detail: data, bubbles: true, composed: true});
              this.dispatchEvent(event);
          }

          /**
           * Checks inside the comment text if there is a url inside.
           * check: http://stackoverflow.com/questions/30970068/js-regex-url-validation
           *
           * @param commentText {String}
           * @returns {*}
           */
          validateUrl(commentText) {
              var str = commentText;
              var expression = /\(?(?:(http|https|ftp):\/\/)?(?:((?:[^\W\s]|\.|-|[:]{1})+)@{1})?((?:www.)?(?:[^\W\s]|\.|-)+[\.][^\W\s]{2,4}|localhost(?=\/)|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::(\d*))?([\/]?[^\s\?]*[\/]{1})*(?:\/?([^\s\n\?\[\]\{\}\#]*(?:(?=\.)){1}|[^\s\n\?\[\]\{\}\.\#]*)?([\.]{1}[^\s\?\#]*)?)?(?:\?{1}([^\s\n\#\[\]]*))?([\#][^\s\n]*)?\)?/gi;
              var regex = new RegExp(expression);

              if (!str.match(regex)) {
                  return str;
              } else {
                  var txt = str;
                  for (var i = 0; i < str.match(regex).length; i++) {
                      var replacement;
                      if (str.match(regex)[i].startsWith("http")) {
                          replacement = "<a href='" + str.match(regex)[i] + "' target='_blank' class='highlight'>"+ str.match(regex)[i] +"</a>"
                      } else {
                          replacement = "<a href='http://" + str.match(regex)[i] + "' target='_blank' class='highlight'>"+ str.match(regex)[i] +"</a>"
                      }
                      txt = txt.replace(str.match(regex)[i], replacement);
                  }
                  return txt;
              }
          }

          _replaceNewLines(requirementDesc) {
              return requirementDesc.replace(/(?:\r\n|\r|\n)/g, '<br />');
          }

          _validateUrlAndReplaceNewLines(requirementDesc) {
              return this._replaceNewLines(this.validateUrl(requirementDesc));
          }

          /**
           * Event handler for adding new comments to the DOM. Needs to fire a resize event so that the iron-list can
           * resize appropriately.
           *
           * @param e
           * @private
           */
          _handleCommentsDomChange(e) {
              let event = new CustomEvent('resize', {bubbles: true, composed: true});
              this.dispatchEvent(event);
          }
      }
      window.customElements.define(commentsList.is, commentsList);
    </script>

</dom-module>
