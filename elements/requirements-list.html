<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../paper-card/paper-card.html">
<link rel="import" href="../../paper-button/paper-button.html">
<link rel="import" href="../../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../paper-item/paper-item.html">
<link rel="import" href="../../paper-toolbar/paper-toolbar.html">
<link rel="import" href="../../paper-dialog/paper-dialog.html">
<link rel="import" href="../../paper-toast/paper-toast.html">
<link rel="import" href="../../neon-animation/animations/fade-in-animation.html">
<link rel="import" href="../../neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../../iron-ajax/iron-ajax.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../iron-icons/iron-icons.html">
<link rel="import" href="../../iron-icons/editor-icons.html">
<link rel="import" href="../../iron-list/iron-list.html">
<link rel="import" href="../../iron-meta/iron-meta.html">
<link rel="import" href="../../iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="req-user.html">
<link rel="import" href="comments-list.html">
<link rel="import" href="../file-gallery.html">
<link rel="import" href="requirement-card.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="requirements-list">
  <template>
    <style include="shared-styles iron-flex iron-flex-alignment">
      :host {
        display: block;
        height: 100%;
        width: 100%;
      }

      paper-card {
        max-width: 300px;
        min-width: 300px;
      }

      #requirementsList {
        @apply(--layout-center);
        height: 100%;
        width: 100%;
      }

      paper-material {
        display: block;
        border-radius: 2px;
        width: 100%;
        max-width: 800px;
        box-sizing: border-box;
        margin: 5px;
        padding: 0 16px 0 16px;
        background: white;
      }

      paper-fab {
        --paper-fab-background: var(--default-primary-color);
      }

      paper-toast {
        z-index: 105;
      }

      .flex-horizontal {
        @apply(--layout-horizontal);
      }

      .flexchild {
        @apply(--layout-flex);
      }

      .flex-end-align {
        margin-top: auto;
        margin-bottom: auto;
      }

      paper-button {
        float: right;
        margin: 20px;
      }

      .hide {
        display: none;
      }

      #bottomToolbar {
        position: fixed;
        bottom: 50px;
        left: 10px;
        z-index: 105;
        width: auto;
        padding: 10px;
      }

      #grid .starIcon {
        float: right;
        margin: 20px;
      }

      .grid-item {
        margin: 5px;
        margin-bottom: 10px;
        width: 250px;
      }

      iron-scroll-threshold {
        height: 100%;
        overflow: auto;
      }
    </style>

    <iron-ajax id="requirementsRequest"
               loading="{{loading}}"
               url="[[_resourceUrl]]"
               headers="[[authHeader]]"
               params="[[_requirementsRequestParameters]]"
               on-response="_handleRequirementsResponse"
               debounce-duration="600"
               auto></iron-ajax>

    <iron-ajax id="deleteRequirementRequest"
               loading="{{loading}}"
               handle-as="json" content-type="application/json"
               method="DELETE"
               headers="[[authHeader]]"
               on-response="_handleDeleteRequirementResponse"
               on-error="errorHandler"></iron-ajax>

    <iron-ajax id="postCommentRequest"
               loading="{{loading}}"
               handle-as="json"
               url="{{_apiBaseUrl}}comments"
               content-type="application/json"
               method="POST"
               headers="[[authHeader]]"
               on-response="_handleCommentResponse"
               last-response="{{postResponse}}"
               on-error="errorHandler"></iron-ajax>

    <iron-ajax id="deleteCommentRequest"
               loading="{{loading}}"
               handle-as="json"
               content-type="application/json"
               method="DELETE"
               headers="[[authHeader]]"
               on-response="_handleDeleteCommentResponse"
               on-error="errorHandler"></iron-ajax>

      <template is="dom-repeat" items="{{requirements}}" filter="{{filterItems(searchFilter)}}" initial-count="5">
        <requirement-card id="requirement{{item.requirementItem.id}}" view="{{view}}" requirement="[[item.requirementItem]]"
                          authorized="{{authorized}}" auth-token="{{authToken}}"  current-user="{{currentUser}}" loading="{{loading}}">
        </requirement-card>
      </template>

    <!-- this element will load more data when the user scrolls down and reached the lower threshold -->
    <iron-scroll-threshold id="scrollThreshold"
                           on-lower-threshold="_loadMoreData"
                           scroll-target="document">
    </iron-scroll-threshold>

    <paper-dialog id="deleteRequirementDialog"
                  on-iron-overlay-closed="_handleDeleteRequirementClosed"
                  entry-animation="fade-in-animation"
                  exit-animation="fade-out-animation"
                  modal>
      <h2>Delete Requirement?</h2>
      <p>This action can't be undone! Are you sure that you want to permanently delete this requirement?</p>
      <div class="buttons">
        <paper-button dialog-dismiss>Cancel</paper-button>
        <paper-button dialog-confirm autofocus>Delete</paper-button>
      </div>
    </paper-dialog>

    <!-- Dialog for deleting a comment -->

    <paper-dialog id="deleteCommentDialog"
                  entry-animation="fade-in-animation"
                  exit-animation="fade-out-animation"
                  on-iron-overlay-closed="_handleDeleteCommentDialogClosed"
                  modal>
      <h2>Delete Comment?</h2>
      <p>This action can't be undone! Are you sure that you want to permanently delete this comment?</p>
      <div class="buttons">
        <paper-button dialog-dismiss>Cancel</paper-button>
        <paper-button dialog-confirm autofocus>Delete</paper-button>
      </div>
    </paper-dialog>

    <!-- Dialog for showing comments in the grid view: -->

    <paper-dialog id="commentsDialog" on-iron-overlay-closed="deleteLeftoverComment" entry-animation="fade-in-animation" exit-animation="fade-out-animation"
                  style="min-width:40%; max-width:85%; top:100px; max-height: 80%; overflow:scroll;">
      <h2>Comments</h2>
      <p style="max-height: 80%;">
        <comments-list></comments-list>
      <div class="container flex-horizontal" hidden="[[!authorized]]">
        <paper-input is="iron-input" on-input="_handleCommentInput" label="Add a comment..." class="flexchild comments-input" on-keydown="_handleCommentEnter">
        </paper-input>
        <paper-fab id="fab" mini icon="send" class="flex-end-align" on-click="postGridComment"></paper-fab>
      </div>
      </p>
    </paper-dialog>

    <!-- Floating toolbar for selected requirements: -->

    <paper-card elevation="5" id="bottomToolbar" hidden>
      <span>{{selectedRequirements.length}} Requirements selected.</span>
      <paper-icon-button icon="file-download" on-click="_exportSelectedRequirements"></paper-icon-button>
      <paper-icon-button icon="close" on-click="_closeBottomToolbar"></paper-icon-button>
    </paper-card>

    <!-- Toast for toast notifications: -->

    <paper-toast id="toast" text="[[toastFeedback]]"></paper-toast>

  </template>

  <script>
      class requirementsList extends Polymer.Element {
          static get is() { return 'requirements-list'; }

          static get properties() {
              return {
                  _apiBaseUrl: {
                      type: String,
                      value: 'https://requirements-bazaar.org/bazaar/'
                  },
                  _fileApiBaseUrl: {
                      type: String,
                      value: 'https://requirements-bazaar.org/fileservice/files/'
                  },
                  currentUser: {
                      type: String
                  },
                  /**
                   * Defines whether the user is logged in or not.
                   */
                  authorized: {
                      type: Boolean,
                      value: false
                  },
                  authHeader: {
                      type: Array
                  },
                  authToken: {
                      type: String,
                      observer: '_authTokenChanged'
                  },
                  categoryId: {
                      type: Number,
                      observer: '_categoryIdChanged'
                  },
                  /**
                   * The sorting parameter of requirements, either `date`, `last_activity`, `name`, `vote`, `comment`, `follower` or `realized`.
                   */
                  sorting: {
                      type: String,
                      value: 'date',
                      notify: true
                  },
                  sortDirection: {
                      type: String,
                      value: '-',
                      notify: true,
                      reflectToAttribute: true
                  },
                  /**
                   * Whether to show 'open' or 'realized' requirements.
                   */
                  requirementsStateFilter: {
                      type: String,
                      value: 'open',
                      notify: true
                  },
                  _resourceUrl: {
                      type: String,
                      computed: '_computeResourceURL(_apiBaseUrl, categoryId)'
                  },
                  _lastRequestCategoryId: {
                      type: Number
                  },
                  _lastRequestSorting: {
                      type: String
                  },
                  requirements: {
                      type: Array,
                      value: []
                  },
                  selectedRequirements: {
                      type: Array,
                      value: [],
                      notify: true
                  },
                  postUrl: String,
                  body: Object,
                  postResponse: Object,
                  /**
                   * The text shown on the paper-toast element for notifying the user.
                   */
                  toastFeedback: String,
                  header: {
                      type:Object,
                      notify: true
                  },
                  /**
                   * Search filter for the requirements list.
                   */
                  searchFilter: {
                      type: String,
                      value: '',
                      //observer: '_searchFilterChanged'
                  },
                  /**
                   * The parameters for the request to the requirements resource.
                   */
                  _requirementsRequestParameters: {
                      type: Object,
                      notify: true,
                      computed: '_computeRequirementsRequestParameters(_apiBaseUrl, categoryId, sorting, sortDirection, requirementsStateFilter, _requirementsRequestPerPage, _requirementsRequestCurrentPage, searchFilter)',
                      observer: '_requirementsRequestParametersUpdated'
                  },
                  /**
                   * Defines how many requirements are loaded per page.
                   * TODO: recalculate when resizing the window.
                   */
                  _requirementsRequestPerPage: {
                      type: Number,
                      value: 14
                  },
                  /**
                   * Stores the current page number.
                   */
                  _requirementsRequestCurrentPage: {
                      type: Number,
                      value: 0 // because we get a scroll lower threshold event once the page loads
                  },
                  /**
                   * The requirement's element to be deleted.
                   */
                  elem: Object,
                  /**
                   * Stores the requirement that is going to be deleted, while modal dialog is shown.
                   */
                  requirementToDelete: {
                      type: Object
                  },
                  commentToDeleteData: {
                      type: Object
                  },
                  filterValue: {
                      type: String,
                      value: ''
                  },
                  buttons: {
                      type: Array,
                      value: [],
                      notify: true
                  },
                  list: {
                      type: Boolean,
                      notify: true,
                      observer: "_hasEnoughItems"
                  },
                  repositories: {
                      type: Object,
                      notify: true,
                      reflectToAttribute: true
                  },
                  _contributorsVisible: {
                      type: Object,
                      value: []
                  },
                  view: {
                      type: String,
                      notify: true
                  },
                  refreshing: {
                      type: Boolean,
                      value: false
                  },
                  /**
                   * Whether any loading operation is currently active.
                   */
                  loading: {
                      type: Boolean,
                      notify: true
                  },
                  observers: [
                      'manageSelReq(selectedRequirements.splices)'
                  ]
              };
          }

          constructor() {
              super();
              this._boundHandleShowToast = this._handleShowToast.bind(this);
              this._boundHandleDeleteRequirement = this._handleDeleteRequirement.bind(this);
              this._boundHandleDeleteComment = this._handleDeleteComment.bind(this);
              this._boundHandleSelectRequirement = this._handleSelectRequirement.bind(this);
              this._boundHandleUnselectRequirement = this._handleUnselectRequirement.bind(this);
          }

          connectedCallback() {
              super.connectedCallback();
              window.addEventListener('show-toast',  this._boundHandleShowToast);
              window.addEventListener('delete-requirement',  this._boundHandleDeleteRequirement);
              window.addEventListener('delete-comment',  this._boundHandleDeleteComment);
              window.addEventListener('select-requirement',  this._boundHandleSelectRequirement);
              window.addEventListener('unselect-requirement',  this._boundHandleUnselectRequirement);
          }

          _authTokenChanged(token) {
              this.authorized = true;
              this.authHeader = {authorization: "Bearer " + token};
          }

          _hasEnoughItems () {
              if (!this.viewOption !== 'list') {
                  var n = Math.floor((window.innerWidth - 300) / 300);
                  var free = (window.innerWidth - 300) - n * (300 + 20);
                  this.style.paddingLeft = "" + free / 2 + "px";
              } else {
                  this.style.paddingLeft = "0px";
              }
          }

          /**
           * Computes the resource URL for the requirements request.
           */
          _computeResourceURL (apiBaseUrl, categoryId) {
              return apiBaseUrl + 'categories/' + categoryId + '/requirements';
          }

          _searchFilterChanged(searchFilter) {
              this.shadowRoot.querySelector('#scrollThreshold').clearTriggers();
              this._requirementsRequestCurrentPage = 0;
          }

          /**
           * Computes the parameter array for the request to the requirements resource.
           *
           * @param requirementsStateFilter {string} the requirement's state, either 'open', 'realized' or 'all'.
           */
          _computeRequirementsRequestParameters(apiBaseUrl, categoryId, sorting, sortDirection, requirementsStateFilter, requirementsRequestPerPage, requirementsRequestCurrentPage, searchFilter) {
              this._resourceUrl = apiBaseUrl + 'categories/' + categoryId + '/requirements';

              if (this._requirementsRequestParameters) {

                  // if we have a new search string, a new component ID or a new state, reset the page to 0
                  if ((this._requirementsRequestParameters.search !== searchFilter) ||
                      (this._requirementsRequestParameters.state !== requirementsStateFilter) ||
                      (this._lastRequestCategoryId !== categoryId)) {
                      requirementsRequestCurrentPage = 0;

                      // scroll to top
                      this.shadowRoot.querySelector('#scrollThreshold').scroll(0, 0);
                  }

                  // if we have a new sorting parameter, reset the sort direction
                  if (this._lastRequestSorting !== sorting) {
                      if (['date', 'last_activity', 'vote', 'comment', 'follower'].indexOf(sorting) >= 0) {
                          sortDirection = '-';
                      } else {
                          sortDirection = '+';
                      }
                  }

                  // check if we have a new sorting or state parameter; if yes, reset the list
                  if ((this._requirementsRequestParameters.sort !== (sortDirection + sorting)) || (this._requirementsRequestParameters.state !== requirementsStateFilter)) {
                      this.requirements = [];
                      requirementsRequestCurrentPage = 0;

                      // scroll to top
                      this.shadowRoot.querySelector('#scrollThreshold').scroll(0, 0);
                  }
              }

              this._lastRequestCategoryId = categoryId;
              this._lastRequestSorting = sorting;

              var parameters = new Object();
              parameters.sort = sortDirection + sorting;
              parameters.per_page = requirementsRequestPerPage;
              parameters.page = requirementsRequestCurrentPage;
              // better check this type as it's a public property of the element
              if (requirementsStateFilter === 'open') {
                  parameters.state = 'open';
              } else if (requirementsStateFilter === 'realized') {
                  parameters.state = 'realized';
              } else if (requirementsStateFilter === 'all') {
                  parameters.state = 'all';
              }
              parameters.search = searchFilter;

              this._requirementsRequestCurrentPage = requirementsRequestCurrentPage;
              this.sortDirection = sortDirection;

              return parameters;
          }

          /**
           * Called when some of the requirements request parameters change, e.g. the state is set from 'open' to
           * 'realized'. In that case, we need to refresh the requirements list.
           *
           * @param _requirementsRequestParameters {array} the requirements request parameter.
           */
          _requirementsRequestParametersUpdated(_requirementsRequestParameters) {
              //this.refresh();
          }

          refresh() {
              this.shadowRoot.querySelector('#requirementsRequest').generateRequest();
          }

          manageSelReq(selReq) {
              if (this.selectedRequirements.length !== 0) {
                  this.shadowRoot.querySelector('#bottomToolbar').hidden = false;
              }
          }

          showRepoSearchResults() {
              this.repositories = this.searchRepositories.items;
          }

          _exportSelectedRequirements(e) {
              var selectedRequirements = [];
              for (var i=0; i < this.selectedRequirements.length; i++) {
                  for (var j=0; j < this.requirements.length; j++) {
                      if (parseInt(this.selectedRequirements[i]) === this.requirements[j].requirementItem.id) {
                          selectedRequirements.push(this.requirements[j].requirementItem);
                      }
                  }
              }

              //If JSONData is not an object then JSON.parse will parse the JSON string in an Object
              var arrData = typeof selectedRequirements != 'object' ? JSON.parse(selectedRequirements) : selectedRequirements;

              var CSV = '';
              //Set Report name in first row or line

              CSV += 'Requirements of ' + arrData[0].categories[0].name + '\r\n\n';

              var row = 'NAME; DESCRIPTION; CREATION DATE; CREATOR; CATEGORY';

              //append Label row with line break
              CSV += row + '\r\n';

              //1st loop is to extract each row
              for (var i = 0; i < arrData.length; i++) {
                  var row = '';

                  row += '"' + arrData[i].name + '";';
                  row += '"' + arrData[i].description + '";';
                  row += '"' + arrData[i].creationDate + '";';
                  row += '"' + arrData[i].creator.userName + '";';
                  row += '"' + arrData[i].categories[0].name + '"';

                  //add a line break after each row
                  CSV += row + '\r\n';
              }

              if (CSV == '') {
                  //TODO: display toast
                  alert('Invalid data');
                  return;
              }

              //Generate a file name
              var fileName = arrData[0].categories[0].name + '_';
              //this will remove the blank-spaces from the name and replace it with an underscore
              fileName += 'Requirements'.replace(/ /g, '_');

              //Initialize file format you want csv or xls
              var uri = 'data:text/csv;charset=utf-8,' + encodeURI(CSV);

              //this trick will generate a temp <a /> tag
              var link = document.createElement('a');
              link.setAttribute('type', 'text/csv');
              link.href = uri;

              //set the visibility hidden so it will not effect on your web-layout
              link.style = 'visibility:hidden';
              link.download = fileName + '.csv';

              //this part will append the anchor tag and remove it after automatic click
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
          }

          postGridComment(e) {
              var reqId = e.currentTarget.parentNode.parentNode.querySelector('comments-list').requirementId;
              var request = this.shadowRoot.querySelector('#postCommentRequest');
              var message = e.currentTarget.value;
              request.body = JSON.stringify({
                  "requirementId": reqId,
                  "message": message
              });
              request.generateRequest();

              e.currentTarget.value = '';
              e.currentTarget.parentNode.parentNode.querySelector('.comments-input').value = null;
          }

          _handleAddCommentTap(e) {
              var currentReqId = e.model.req.id;
              var request = this.shadowRoot.querySelector('#postCommentRequest');
              var message;
              if (this.viewOption === 'list') {
                  message = this.shadowRoot.querySelector('#comment' + currentReqId).value;
              } else {
                  message = this.shadowRoot.querySelector('#commentsDialog').querySelector('paper-input').value;
              }
              if (message != null && (message !== '')) {
                  request.body = JSON.stringify({
                      "requirementId": parseInt(currentReqId),
                      "message": message
                  });
                  request.generateRequest();
              } else {
                  this.shadowRoot.querySelector('#toast').text = 'Comment can\'t be empty!';
                  this.shadowRoot.querySelector('#toast').open();
              }
              var message;
              if (this.viewOption === 'list') {
                  this.shadowRoot.querySelector('#comment' + currentReqId).value = '';
              } else {
                  this.shadowRoot.querySelector('#commentsDialog').querySelector('paper-input').value = '';
              }
              this.shadowRoot.querySelector('#comment' + currentReqId).value = null;
          }

          _handleCommentResponse(data) {
              var requirementId = data.detail.response.requirementId;
              if (this.viewOption === 'list') {
                  this.shadowRoot.querySelector('#comments' + requirementId).querySelector('comments-list').refresh();
              } else {
                  // reload comments in grid view
                  this.shadowRoot.querySelector('#commentsDialog').querySelector('comments-list').refresh();
              }

          }

          _handleCommentInput(e) {
              var fab = e.currentTarget.parentNode.querySelector('#fab');
              var message;
              if (this.viewOption === 'list') {
                  message = this.shadowRoot.querySelector('#comment' + requirementId).value;
              } else {
                  message = this.shadowRoot.querySelector('#commentsDialog').querySelector('paper-input').value;
              }
              if (message) {
                  fab.style.display = 'block';
              } else {
                  fab.style.display = 'none';
              }
          }

          errorHandler (e, detail) {
              this.shadowRoot.querySelector('#toast').text = detail.error.message;
              this.shadowRoot.querySelector('#toast').open();
          }

          handleResponseGithubIssue() {
              this.shadowRoot.querySelector('#toast').text = 'Issue posted to Github';
              this.shadowRoot.querySelector('#toast').open();
          }

          _closeBottomToolbar() {
              this.shadowRoot.querySelector('#bottomToolbar').hidden = true;
              //TODO: fix unselection as soon as we use iron-list
              for (var i=0; i < this.selectedRequirements.length; i++) {
                  this.shadowRoot.querySelector('#requirement' + this.selectedRequirements[i]).selected = false;
              }
              this.selectedRequirements = [];
          }

          openCommentsDialog(e) {
              this.shadowRoot.querySelector('#commentsDialog').querySelector("comments-list").requirementId = e.model.item.requirementItem.id;
              this.shadowRoot.querySelector('#commentsDialog').querySelector("comments-list").refresh();
              this.shadowRoot.querySelector('#commentsDialog').open();
          }

          deleteLeftoverComment(e) {
              this.shadowRoot.querySelector('#commentsDialog').querySelector("comments-list").comments = [];
          }

          /**
           searchFilter: function (val) {
          return function (item) {
            if (!val) {
              return true;
            }
            //return (item.name && ~item.name.toLowerCase().indexOf(val.toLowerCase()));
            return (item.name && ~item.name.toLowerCase().indexOf(val.toLowerCase())) || (item.description && ~item.description.toLowerCase().indexOf(val.toLowerCase()));
          };
        },**/

          _handleCommentEnter(e) {
              //TODO: refactor the code
              // keyCode 13 is Enter
              if (e.keyCode === 13) {
                  // check if the Enter key was pressed...
                  if (!e.ctrlKey) {
                      if (this.viewOption === 'list') {
                          this._handleAddCommentTap(e);
                      } else {
                          this.postGridComment(e);
                      }
                      e.preventDefault();
                  } else {
                      e.currentTarget.value += "<br/>";
                  }
              }
          }

          /**
           * Handles the delete modal dialog closed event.
           *
           * @param e
           * @private
           */
          _handleDeleteRequirementClosed(e) {
              if (e.detail.confirmed) {
                  var requirement = this.requirementToDelete;
                  var request = this.shadowRoot.querySelector('#deleteRequirementRequest');
                  request.url = this._apiBaseUrl + 'requirements/' + requirement.id;

                  request.generateRequest();
              }
          }

          /**
           * Handles the result of the DELETE requirement request.
           *
           * @param e
           * @private
           */
          _handleDeleteRequirementResponse(e) {
              //TODO: check result

              this.toastFeedback = 'Requirement deleted successfully!';
              this.shadowRoot.querySelector('#toast').open();

              // now delete the requirement from the model
              for (var i = 0; i<this.requirements.length; i++) {
                  if (this.requirements[i].requirementItem.id === this.requirementToDelete.id) {
                      this.splice('requirements', i, 1);
                      break;
                  }
              }

              this.requirementToDelete = null;
          }

          _handleRequirementsResponse(e) {
              if (this.refreshing){
                this.refreshing = false;
                this.requirements = [];
              }
              var requirementsResponse = e.detail.response;
              var requirementsToAdd = [];
              // remember scroll position
              //var firstVisibleIndex = this.$.requirementsList.firstVisibleIndex;

              requirementsResponse.forEach(function(requirementItem) {
                  // check if the requirement is already existing in the local model
                  var existing = false;
                  for (var i=0; i<this.requirements.length; i++) {
                      if (this.requirements[i].requirementItem.id === requirementItem.id) {
                          existing = true;
                          break;
                      }
                  }

                  if (!existing) {
                      var requirement = {"opened": false, "requirementItem": requirementItem};
                      requirementsToAdd.push(requirement);
                  }
              }.bind(this));

              // push the items to the requirements array and notify Polymer
              var index = this.requirements.length;
              this.requirements.push.apply(this.requirements, requirementsToAdd);
              this.notifySplices('requirements', [{ index: index, removed: [], addedCount: requirementsToAdd.length, object: this.requirements, type: 'splice'}]);

              // if we get back the maximum number of items per page, the likelihood is high that there is another page...
              if (requirementsResponse.length === this._requirementsRequestPerPage) {
                  this.shadowRoot.querySelector('#scrollThreshold').clearTriggers();
              }
          }

          _loadMoreData(e) {
              if (this.requirements && (this.requirements.length > 0)) {
                  this._requirementsRequestCurrentPage++;
              }
          }

          /**
           * Shows a toast notification.
           *
           * @param detail a text that is displayed in the toast.
           */
          _handleShowToast(e) {
              this.toastFeedback = e.detail;
              this.shadowRoot.querySelector('#toast').open();
          }

          _handleDeleteRequirement(e) {
              this.requirementToDelete = e.detail;
              this.shadowRoot.querySelector('#deleteRequirementDialog').open();
          }

          _handleDeleteComment(e) {
              this.commentToDeleteData = e.detail;
              this.shadowRoot.querySelector('#deleteCommentDialog').open();
          }

          /**
           * Handles the delete modal dialog closed event.
           *
           * @param e
           * @private
           */
          _handleDeleteCommentDialogClosed(e) {
              if (e.detail.confirmed) {
                  var commentData = this.commentToDeleteData;
                  var request = this.shadowRoot.querySelector('#deleteCommentRequest');
                  request.url = this._apiBaseUrl + 'comments/' + commentData.comment.id;

                  request.generateRequest();
              }
          }

          /**
           * Handles the result of the DELETE requirement request.
           *
           * @param e
           * @private
           */
          _handleDeleteCommentResponse(e) {
              this.toastFeedback = 'The comment was successfully deleted.';
              this.shadowRoot.querySelector('#toast').open();

              // now execute the delete callback
              this.commentToDeleteData.onDelete();

              this.commentToDeleteData = null;
          }

          /**
           * Filters the requirements and only returns those whose name or description contains the search filter string.
           *
           * Thanks to https://github.com/PolymerElements/iron-list/issues/193
           *
           * @param requirements
           * @param searchFilter
           */
          filterItems(searchFilter) {
              return function(item) { // Array.prototype.filter
                  return (item.requirementItem.name && ~item.requirementItem.name.toLowerCase().indexOf(searchFilter.toLowerCase())) || (item.requirementItem.description && ~item.requirementItem.description.toLowerCase().indexOf(searchFilter.toLowerCase()));
              };
          }

          _handleSelectRequirement(e) {
              this.push('selectedRequirements', e.detail.id);

              this.shadowRoot.querySelector('#bottomToolbar').hidden = (this.selectedRequirements.length === 0);
          }

          _handleUnselectRequirement(e) {
              var index = this.selectedRequirements.indexOf(e.detail.id);
              if (index > -1) {
                  this.splice('selectedRequirements', index, 1);
              }

              this.shadowRoot.querySelector('#bottomToolbar').hidden = (this.selectedRequirements.length === 0);
          }

          /**
           * Still needed for requirements cards in grid view
           */

          /**
           * Calculates the specific star icon to show for the voting feature of the requirements.
           *
           * @param vote the vote field coming from the backend, either 'UP_VOTE' or 'NO_VOTE'.
           * @param authorized whether the user is currently logged in or not.
           * @returns {string} the icon, either a filled star or just the outlines of a star.
           * @private
           */
          _calculateStarIcon(vote, authorized) {
              if (authorized && (vote === 'UP_VOTE')) {
                  return 'star';
              }
              return 'star-border';
          }

          /**
           * Calculates the CSS class for the star icon of the voting feature of the requirements.
           *
           * @param vote the vote field coming from the backend, either 'UP_VOTE' or 'NO_VOTE'.
           * @param authorized whether the user is currently logged in or not.
           * @returns {string} the CSS class for the star icon.
           * @private
           */
          _calculateStarClass(vote, authorized) {
              if (authorized && (vote === 'UP_VOTE')) {
                  return 'colored';
              }
          }

          _categoryIdChanged() {
              this.refreshing = true;
              this.sorting = 'date';
              this.sortDirection = '-';
              this.requirementsStateFilter = 'open';
              this.requirementsRequestPerPage = 14;
              this.requirementsRequestCurrentPage = 0;
              this.searchFilter = '';
              this._computeRequirementsRequestParameters(this._apiBaseUrl, this.categoryId, this.sorting, this.sortDirection,
                  this.requirementsStateFilter, this.requirementsRequestPerPage, this.requirementsRequestCurrentPage,
                  this.searchFilter);
              this._computeResourceURL(this._apiBaseUrl, this.categoryId);
          }
      }
      window.customElements.define(requirementsList.is, requirementsList);
  </script>

</dom-module>
